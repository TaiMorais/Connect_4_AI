# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11lq9GS2dDWoR9kYzFeL-z3OSApHdK-My
"""

#!/bin/python3.11

import numpy as np
from os import system, name
import math
import time
import timeit

ROWS = 6
COLUMNS = 7

FACTOR = .8 #F
COST_LIMIT = 200_000 #limite

DEPTH_FLOATING_POINT = (math.log(
  (COST_LIMIT)
  / (ROWS * COLUMNS),
  COLUMNS
) / FACTOR)

DEPTH = math.floor(DEPTH_FLOATING_POINT)


# ------------------------------------------------------------------------------
def clear():
  # para windows
  if name == 'nt':
    _ = system('cls')

  # para mac e linux(aqui, os.name eh 'posix')
  else:
    _ = system('clear')


# ------------------------------------------------------------------------------
def create_board():
  board = np.zeros((ROWS, COLUMNS))
  return board


# ------------------------------------------------------------------------------
def valid_location(board, column):
  return board[ROWS - 1][column] == 0


# ------------------------------------------------------------------------------
def drop_piece(board, column, piece):
  for r in range(ROWS):
    if board[r][column] == 0:
      board[r][column] = piece
      return


# ------------------------------------------------------------------------------
# piece = peça do jogador a verificar se ganhou
def is_winning_move(board, piece):
  # verifica se existem quatro peças em linha na horizontal, vertical e
  # diagonais.
  for c in range(COLUMNS - 3):
    for r in range(ROWS):
      if (board[r][c] == piece and board[r][c + 1] == piece and
          board[r][c + 2] == piece and board[r][c + 3] == piece):
        return True
  for c in range(COLUMNS):
    for r in range(ROWS - 3):
      if (board[r][c] == piece and board[r + 1][c] == piece and
          board[r + 2][c] == piece and board[r + 3][c] == piece):
        return True
  for c in range(COLUMNS - 3):
    for r in range(ROWS - 3):
      if (board[r][c] == piece and board[r + 1][c + 1] == piece and
          board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece):
        return True
  for c in range(COLUMNS - 3):
    for r in range(3, ROWS):
      if (board[r][c] == piece and board[r - 1][c + 1] == piece and
          board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece):
        return True


# ------------------------------------------------------------------------------
# retorna (coluna do melhor movimento, pontuação do melhor movimento)
def minimax(board, depth: int, alpha: int, beta: int,
            maximizing_player: bool, nodes: int = 0):
  if is_winning_move(board, 2):  # IA ganhou
    return (None, 100, 1)
  elif is_winning_move(board, 1):  # jogador humano ganhou
    return (None, -100, 1)
  elif len(get_valid_locations(board)) == 0:  # jogo empatado
    return (None, 0, 1)
  elif depth == 0:  # profundidade máxima atingida
    # Avalia o tabuleiro usando a heurística para a IA
    return (None, evaluate_board(board, 2), 1)

  valid_locations = get_valid_locations(board)
  if maximizing_player:
    value = -np.Inf
    column = np.random.choice(valid_locations)
    for col in valid_locations:
      # Copia o tabuleiro e realiza o movimento nessa nova cópia (preservando
      # o estado original do tabuleiro, para as outras chamadas recursivas).
      temp_board = board.copy()
      drop_piece(temp_board, col, 2)
      new_score, visited = minimax(
        temp_board, depth - 1, alpha, beta, False)[1:]
      nodes += visited

      if new_score > value:
        value = new_score
        column = col
      alpha = max(alpha, value)
      if alpha >= beta:
        break
    return column, value, (nodes + 1)

  else:  # minimizing player
    value = np.Inf
    column = np.random.choice(valid_locations)
    for col in valid_locations:
      # Copia o tabuleiro e realiza o movimento nessa nova cópia (preservando
      # o estado original do tabuleiro, para as outras chamadas recursivas).
      temp_board = board.copy()
      drop_piece(temp_board, col, 1)
      new_score, visited = minimax(
        temp_board, depth - 1, alpha, beta, True)[1:]
      nodes += visited

      if new_score < value:
        value = new_score
        column = col
      beta = min(beta, value)
      if alpha >= beta:
        break
    return column, value, (nodes + 1)


# ------------------------------------------------------------------------------
def get_valid_locations(board):
  valid_locations = []
  for col in range(COLUMNS):
    if valid_location(board, col):
      valid_locations.append(col)
  return valid_locations


# ------------------------------------------------------------------------------
def evaluate_board(board, piece):
  score = 0

  # Sequências de peças
  score += count_sequences(board, piece)

  return score


def count_sequences(board, piece):
  score = 0

  # Verifica sequências horizontais
  for r in range(ROWS):
    for c in range(COLUMNS - 3):
      fatia = board[r, c:c+4]
      score += avaliar_fatia(fatia, piece)

  # Verifica sequências verticais
  for c in range(COLUMNS):
    for r in range(ROWS - 3):
      fatia = board[r:r+4, c]
      score += avaliar_fatia(fatia, piece)

  # Verifica sequências diagonais (/)
  for r in range(ROWS - 3):
    for c in range(COLUMNS - 3):
      fatia = [board[r+i, c+i] for i in range(4)]
      score += avaliar_fatia(fatia, piece)

  # Verifica sequências diagonais (\)
  for r in range(3, ROWS):
    for c in range(COLUMNS - 3):
      fatia = [board[r-i, c+i] for i in range(4)]
      score += avaliar_fatia(fatia, piece)

  return score


def avaliar_fatia(fatia: np.ndarray, piece: int):
  score = 0

  # Define os valores para avaliação
  player_piece = piece
  # Considerando que as peças são representadas por 1 e 2
  opponent_piece = 3 - piece

  # Avalia a sequência
  player_piece_count = np.count_nonzero(fatia == player_piece)
  opponent_piece_count = np.count_nonzero(fatia == opponent_piece)
  empty_count = 4 - player_piece_count - opponent_piece_count

  # (fatia == player_piece) retorna um array de booleanos, onde True indica
  # que o valor é igual a player_piece

  # np.count_nonzero(...) retorna a quantidade de valores True no array de
  # booleanos, efetivamente contando quantas peças player_piece estão em
  # fatia.

  # player_piece_count e opponent_piece_count são, então, usados para avaliar
  # o quão bom o movimento atual é.

  # ==== HEURISTICA ITERAÇÃO 1 (GPT) ===========================================

  # if player_piece_count == 4:
  #   score += 100
  # elif player_piece_count == 3 and empty_count == 1:
  #   score += 5
  # elif player_piece_count == 2 and empty_count == 2:
  #   score += 2
  # if opponent_piece_count == 3 and empty_count == 1:
  #   score -= 4

  # ==== HEURISTICA ITERAÇÃO 2 (Artigo)=========================================

  # if player_piece_count == 4:
  #   score += 1_000_000
  # elif player_piece_count == 3:
  #   score += 1
  # elif opponent_piece_count == 3:
  #   score -= 100
  # elif opponent_piece_count == 4:
  #   score -= 1_000_000

  # ==== HEURISTICA ITERAÇÃO 3 =================================================

  if player_piece_count == 4:
    score += 1_000_000
  elif player_piece_count == 3 and empty_count == 1:
    score += 100
  elif player_piece_count == 2 and empty_count == 2:
    score += 10
  elif player_piece_count == 1 and empty_count == 3:
    score += 1
  elif opponent_piece_count == 1 and empty_count == 3:
    score -= 1
  elif opponent_piece_count == 2 and empty_count == 2:
    score -= 10
  elif opponent_piece_count == 3 and empty_count == 1:
    score -= 100
  elif opponent_piece_count == 4:
    score -= 1_000_000

  return score


def check_full(board):
  return len(get_valid_locations(board)) == 0


# usa cores para imprimir o tabuleiro de forma mais amigável
def print_board_pretty(board: list[list[int]], highlight: int = -1):
  for row in reversed(board):
    for c in row:
      if c == 0:
        print('\033[1;30m○\033[0m ', end='')
      elif c == 1:
        print('\033[34m●\033[0m ', end='')
      elif c == 2:
        print('\033[31m●\033[0m ', end='')
    print()
  for c in range(COLUMNS):
    if c == highlight:
      print(f'\033[1;35m{(c+1)%10}\033[0m ', end='')
    else:
      print(f'{(c+1)%10} ', end='')
  print()


# ------------------------------------------------------------------------------
# CSI457 e CSI701
# Programa Principal
# Data: 06/05/2023
# ------------------------------------------------------------------------------

board = create_board()
game_over = False
turn = 0

clear()
#print(f"Calculated depth: {DEPTH}")
while not game_over:
  # Movimento do Jogador 1
  if turn == 0:

    # Ler o input do usuário e lidar com possíveis erros
    try:
      col = int(input(f"Jogador 1, selecione a coluna (1-{COLUMNS}): ")) - 1
    except EOFError:
      print("\nJogo encerrado")
      break
    except KeyboardInterrupt:
      print("\nJogo encerrado")
      break
    except ValueError:
      print("Entrada inválida, digite novamente.")
      continue

    if valid_location(board, col):
      drop_piece(board, col, 1)
      if is_winning_move(board, 1):
        print("Jogador 1 Vence!! Parabéns!!")
        game_over = True
    else:
      print("Coluna Cheia")
      continue

  # Movimento da IA
  else:

    # Calcula o movimento da IA
    inicio = timeit.default_timer()
    print("Vez da IA")
    col, minimax_score, visited = minimax(board, DEPTH, -np.Inf, np.Inf, True)
    print(f"Nós visitados: {visited}")

    if valid_location(board, col):
      drop_piece(board, col, 2)
      if is_winning_move(board, 2):
        print("Jogador 2 Vence!!!")
        game_over = True
    fim = timeit.default_timer()
    print ('duracao: %f' % (fim - inicio))

  # Verifica se o jogo empatou
  if check_full(board):
    print("Empate!")
    game_over = True

  print_board_pretty(board, col)
  print()
  turn += 1
  turn = turn % 2